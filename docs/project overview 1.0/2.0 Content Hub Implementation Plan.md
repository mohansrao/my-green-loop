# Content Hub & Resource Library - Implementation Plan

## Overview
This document provides a detailed breakdown of technical tasks required to implement the Content Hub & Resource Library feature. Tasks are organized by component and include technical specifications, dependencies, and estimated complexity.

---

## Implementation Strategy

### Approach
We'll implement this feature incrementally in logical phases:
1. **Database & Backend Foundation** - Data models and API structure
2. **Admin Interface** - Tools for content curation
3. **Public Frontend** - User-facing resource hub
4. **Enhancement & Polish** - Bookmarking, search optimization, analytics

### Technology Stack Alignment
- **Backend**: Express.js routes in `server/routes.ts`
- **Database**: Drizzle ORM with PostgreSQL (`db/schema.ts`)
- **Frontend**: React components in `client/src/`
- **UI Components**: Shadcn UI + Radix UI + Tailwind CSS
- **State Management**: TanStack Query for API calls

---

## Phase 1: Database & Schema Implementation

### Task 1.1: Create Database Schema
**File**: `db/schema.ts`

**Description**: Add new tables for content management.

**Implementation**:
```typescript
// Add to db/schema.ts

export const contentCategories = pgTable("content_categories", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  slug: text("slug").notNull().unique(),
  description: text("description"),
  icon: text("icon"),
  color: text("color"),
  order: integer("order").default(0),
  createdAt: timestamp("created_at").defaultNow(),
});

export const contentItems = pgTable("content_items", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  url: text("url").notNull().unique(),
  thumbnailUrl: text("thumbnail_url"),
  contentType: text("content_type").notNull(), // article, video, podcast
  source: text("source"), // domain name
  readingTime: integer("reading_time"), // in minutes
  isFeatured: boolean("is_featured").default(false),
  status: text("status").notNull().default("published"), // draft, published, archived
  viewCount: integer("view_count").default(0),
  shareCount: integer("share_count").default(0),
  bookmarkCount: integer("bookmark_count").default(0),
  createdBy: integer("created_by"), // admin user id
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  publishedAt: timestamp("published_at"),
});

export const contentCategoryMapping = pgTable("content_category_mapping", {
  id: serial("id").primaryKey(),
  contentId: integer("content_id").notNull().references(() => contentItems.id, { onDelete: "cascade" }),
  categoryId: integer("category_id").notNull().references(() => contentCategories.id, { onDelete: "cascade" }),
  isPrimary: boolean("is_primary").default(false),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  uniqueContentCategory: unique().on(table.contentId, table.categoryId),
}));

export const contentTags = pgTable("content_tags", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  slug: text("slug").notNull().unique(),
  usageCount: integer("usage_count").default(0),
  createdAt: timestamp("created_at").defaultNow(),
});

export const contentTagMapping = pgTable("content_tag_mapping", {
  id: serial("id").primaryKey(),
  contentId: integer("content_id").notNull().references(() => contentItems.id, { onDelete: "cascade" }),
  tagId: integer("tag_id").notNull().references(() => contentTags.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  uniqueContentTag: unique().on(table.contentId, table.tagId),
}));

export const contentBookmarks = pgTable("content_bookmarks", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(), // reference to users table when auth is added
  contentId: integer("content_id").notNull().references(() => contentItems.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  uniqueUserContent: unique().on(table.userId, table.contentId),
}));

// Relations
export const contentItemsRelations = relations(contentItems, ({ many }) => ({
  categoryMappings: many(contentCategoryMapping),
  tagMappings: many(contentTagMapping),
  bookmarks: many(contentBookmarks),
}));

export const contentCategoriesRelations = relations(contentCategories, ({ many }) => ({
  contentMappings: many(contentCategoryMapping),
}));

export const contentCategoryMappingRelations = relations(contentCategoryMapping, ({ one }) => ({
  content: one(contentItems, {
    fields: [contentCategoryMapping.contentId],
    references: [contentItems.id],
  }),
  category: one(contentCategories, {
    fields: [contentCategoryMapping.categoryId],
    references: [contentCategories.id],
  }),
}));

// Export types
export type ContentItem = typeof contentItems.$inferSelect;
export type ContentCategory = typeof contentCategories.$inferSelect;
export type ContentTag = typeof contentTags.$inferSelect;
```

**Tasks**:
- [ ] Add table definitions to `db/schema.ts`
- [ ] Add relations between tables
- [ ] Export TypeScript types
- [ ] Run `npm run db:push` to sync database

**Dependencies**: None  
**Estimated Time**: 1-2 hours  
**Complexity**: Medium

---

### Task 1.2: Seed Initial Categories
**File**: `db/seed-categories.ts` (new file)

**Description**: Create script to populate initial content categories.

**Implementation**:
```typescript
import { db } from './index';
import { contentCategories } from './schema';

const initialCategories = [
  { name: 'Climate Action', slug: 'climate-action', icon: 'leaf', color: '#2d5016', order: 1 },
  { name: 'Zero Waste', slug: 'zero-waste', icon: 'recycle', color: '#059669', order: 2 },
  { name: 'Sustainable Fashion', slug: 'sustainable-fashion', icon: 'shirt', color: '#7c3aed', order: 3 },
  { name: 'Renewable Energy', slug: 'renewable-energy', icon: 'zap', color: '#ea580c', order: 4 },
  { name: 'Eco-Products', slug: 'eco-products', icon: 'shopping-bag', color: '#0891b2', order: 5 },
  { name: 'Green Living Tips', slug: 'green-living-tips', icon: 'lightbulb', color: '#eab308', order: 6 },
];

async function seedCategories() {
  await db.insert(contentCategories).values(initialCategories);
  console.log('✅ Categories seeded successfully');
}

seedCategories();
```

**Tasks**:
- [ ] Create seed script
- [ ] Add to `package.json` scripts: `"db:seed-categories": "tsx db/seed-categories.ts"`
- [ ] Run seed script

**Dependencies**: Task 1.1  
**Estimated Time**: 30 minutes  
**Complexity**: Low

---

## Phase 2: Backend API Implementation

### Task 2.1: Create Metadata Fetching Service
**File**: `server/services/metadata-fetcher.ts` (new file)

**Description**: Service to fetch Open Graph metadata from URLs.

**Implementation**:
```typescript
import fetch from 'node-fetch';
import * as cheerio from 'cheerio';

interface MetadataResult {
  title?: string;
  description?: string;
  image?: string;
  type?: 'article' | 'video' | 'podcast';
  siteName?: string;
  author?: string;
}

export async function fetchUrlMetadata(url: string): Promise<MetadataResult> {
  try {
    const response = await fetch(url);
    const html = await response.text();
    const $ = cheerio.load(html);

    // Extract Open Graph / Twitter Card metadata
    const metadata: MetadataResult = {
      title: $('meta[property="og:title"]').attr('content') || $('title').text(),
      description: $('meta[property="og:description"]').attr('content') || $('meta[name="description"]').attr('content'),
      image: $('meta[property="og:image"]').attr('content') || $('meta[name="twitter:image"]').attr('content'),
      type: detectContentType($('meta[property="og:type"]').attr('content') || ''),
      siteName: $('meta[property="og:site_name"]').attr('content'),
      author: $('meta[name="author"]').attr('content'),
    };

    return metadata;
  } catch (error) {
    console.error('Error fetching metadata:', error);
    throw new Error('Failed to fetch metadata from URL');
  }
}

function detectContentType(ogType: string): 'article' | 'video' | 'podcast' {
  if (ogType.includes('video') || ogType.includes('youtube')) return 'video';
  if (ogType.includes('podcast') || ogType.includes('audio')) return 'podcast';
  return 'article';
}

export function extractDomain(url: string): string {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname.replace('www.', '');
  } catch {
    return '';
  }
}

export function estimateReadingTime(wordCount: number): number {
  // Average reading speed: 200 words per minute
  return Math.ceil(wordCount / 200);
}
```

**Tasks**:
- [ ] Install dependencies: `npm install cheerio node-fetch`
- [ ] Create metadata fetching service
- [ ] Add error handling and timeout
- [ ] Test with various URLs (articles, videos, etc.)

**Dependencies**: None  
**Estimated Time**: 2-3 hours  
**Complexity**: Medium-High

---

### Task 2.2: Implement Content API Routes
**File**: `server/routes.ts`

**Description**: Add API endpoints for content CRUD operations.

**Implementation**:
```typescript
// Add these routes to server/routes.ts

import { fetchUrlMetadata, extractDomain } from './services/metadata-fetcher';

// PUBLIC ENDPOINTS

app.get("/api/content", async (req, res) => {
  try {
    const { category, type, search, sort = 'recent', page = 1, limit = 20 } = req.query;
    
    let query = db.query.contentItems.findMany({
      where: and(
        eq(contentItems.status, 'published'),
        category ? exists(
          db.select().from(contentCategoryMapping)
            .where(and(
              eq(contentCategoryMapping.contentId, contentItems.id),
              eq(contentCategoryMapping.categoryId, Number(category))
            ))
        ) : undefined,
        type ? eq(contentItems.contentType, type as string) : undefined,
        search ? or(
          sql`${contentItems.title} ILIKE ${`%${search}%`}`,
          sql`${contentItems.description} ILIKE ${`%${search}%`}`
        ) : undefined
      ),
      with: {
        categoryMappings: {
          with: { category: true }
        }
      },
      orderBy: sort === 'popular' ? desc(contentItems.viewCount) : desc(contentItems.createdAt),
      limit: Number(limit),
      offset: (Number(page) - 1) * Number(limit),
    });

    const items = await query;
    res.json({ items, page: Number(page), limit: Number(limit) });
  } catch (error) {
    console.error('Error fetching content:', error);
    res.status(500).json({ message: "Error fetching content" });
  }
});

app.get("/api/content/featured", async (_req, res) => {
  try {
    const featured = await db.query.contentItems.findMany({
      where: and(
        eq(contentItems.status, 'published'),
        eq(contentItems.isFeatured, true)
      ),
      with: {
        categoryMappings: { with: { category: true } }
      },
      limit: 5,
      orderBy: desc(contentItems.publishedAt),
    });
    res.json(featured);
  } catch (error) {
    res.status(500).json({ message: "Error fetching featured content" });
  }
});

app.get("/api/content/:id", async (req, res) => {
  try {
    const content = await db.query.contentItems.findFirst({
      where: eq(contentItems.id, Number(req.params.id)),
      with: {
        categoryMappings: { with: { category: true } },
        tagMappings: { with: { tag: true } }
      }
    });

    if (!content) {
      return res.status(404).json({ message: "Content not found" });
    }

    // Increment view count
    await db.update(contentItems)
      .set({ viewCount: sql`${contentItems.viewCount} + 1` })
      .where(eq(contentItems.id, Number(req.params.id)));

    res.json(content);
  } catch (error) {
    res.status(500).json({ message: "Error fetching content" });
  }
});

app.get("/api/categories", async (_req, res) => {
  try {
    const categories = await db.query.contentCategories.findMany({
      orderBy: contentCategories.order,
    });
    res.json(categories);
  } catch (error) {
    res.status(500).json({ message: "Error fetching categories" });
  }
});

// ADMIN ENDPOINTS

app.post("/api/admin/content/fetch-metadata", async (req, res) => {
  try {
    const { url } = req.body;
    
    // Check for duplicate URL
    const existing = await db.query.contentItems.findFirst({
      where: eq(contentItems.url, url)
    });
    
    if (existing) {
      return res.status(409).json({ message: "This URL already exists in the library" });
    }

    const metadata = await fetchUrlMetadata(url);
    const domain = extractDomain(url);

    res.json({
      ...metadata,
      source: domain,
      url,
    });
  } catch (error) {
    console.error('Error fetching metadata:', error);
    res.status(500).json({ message: "Failed to fetch URL metadata" });
  }
});

app.post("/api/admin/content", async (req, res) => {
  try {
    const {
      title,
      description,
      url,
      thumbnailUrl,
      contentType,
      source,
      readingTime,
      categoryId,
      isFeatured,
      tags
    } = req.body;

    const [newContent] = await db.insert(contentItems).values({
      title,
      description,
      url,
      thumbnailUrl,
      contentType,
      source,
      readingTime,
      isFeatured: isFeatured || false,
      status: 'published',
      publishedAt: new Date(),
    }).returning();

    // Map to primary category
    await db.insert(contentCategoryMapping).values({
      contentId: newContent.id,
      categoryId: Number(categoryId),
      isPrimary: true,
    });

    // Add tags if provided
    if (tags && tags.length > 0) {
      // Create or find tags, then map them
      // Implementation left for brevity
    }

    res.status(201).json(newContent);
  } catch (error) {
    console.error('Error creating content:', error);
    res.status(500).json({ message: "Error creating content" });
  }
});

app.patch("/api/admin/content/:id", async (req, res) => {
  try {
    const [updated] = await db.update(contentItems)
      .set({ ...req.body, updatedAt: new Date() })
      .where(eq(contentItems.id, Number(req.params.id)))
      .returning();

    if (!updated) {
      return res.status(404).json({ message: "Content not found" });
    }

    res.json(updated);
  } catch (error) {
    res.status(500).json({ message: "Error updating content" });
  }
});

app.delete("/api/admin/content/:id", async (req, res) => {
  try {
    await db.delete(contentItems)
      .where(eq(contentItems.id, Number(req.params.id)));
    res.json({ message: "Content deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: "Error deleting content" });
  }
});
```

**Tasks**:
- [ ] Add public content listing endpoint with filters
- [ ] Add featured content endpoint
- [ ] Add single content detail endpoint with view tracking
- [ ] Add categories listing endpoint
- [ ] Add admin metadata fetch endpoint
- [ ] Add admin content CRUD endpoints
- [ ] Test all endpoints with Postman or similar

**Dependencies**: Task 1.1, Task 2.1  
**Estimated Time**: 4-5 hours  
**Complexity**: High

---

## Phase 3: Admin Interface

### Task 3.1: Create Admin Content Form Page
**File**: `client/src/pages/AdminAddContent.tsx` (new file)

**Description**: Admin interface for adding new content.

**Implementation**:
```typescript
import { useState } from 'react';
import { useMutation, useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Card } from '@/components/ui/card';

export default function AdminAddContent() {
  const [url, setUrl] = useState('');
  const [metadata, setMetadata] = useState(null);
  const [selectedCategory, setSelectedCategory] = useState('');
  const [isFeatured, setIsFeatured] = useState(false);

  const { data: categories } = useQuery({
    queryKey: ['categories'],
    queryFn: () => fetch('/api/categories').then(r => r.json()),
  });

  const fetchMetadata = useMutation({
    mutationFn: (url: string) => 
      fetch('/api/admin/content/fetch-metadata', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url }),
      }).then(r => r.json()),
    onSuccess: (data) => setMetadata(data),
  });

  const createContent = useMutation({
    mutationFn: (data) => 
      fetch('/api/admin/content', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      }).then(r => r.json()),
    onSuccess: () => {
      // Reset form and show success message
      setUrl('');
      setMetadata(null);
      setSelectedCategory('');
      setIsFeatured(false);
    },
  });

  const handleFetchDetails = () => {
    if (url) fetchMetadata.mutate(url);
  };

  const handlePublish = () => {
    if (!metadata || !selectedCategory) return;

    createContent.mutate({
      ...metadata,
      categoryId: selectedCategory,
      isFeatured,
    });
  };

  return (
    <div className="max-w-3xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Add New Resource</h1>

      {/* URL Input */}
      <div className="space-y-4 mb-6">
        <div className="flex gap-2">
          <Input
            placeholder="Paste article or video URL here..."
            value={url}
            onChange={(e) => setUrl(e.target.value)}
            className="flex-1"
          />
          <Button onClick={handleFetchDetails} disabled={!url}>
            Fetch Details
          </Button>
        </div>

        {/* Category Selection */}
        <Select value={selectedCategory} onValueChange={setSelectedCategory}>
          <option value="">Select Category</option>
          {categories?.map(cat => (
            <option key={cat.id} value={cat.id}>{cat.name}</option>
          ))}
        </Select>

        {/* Featured Checkbox */}
        <label className="flex items-center gap-2">
          <Checkbox checked={isFeatured} onCheckedChange={setIsFeatured} />
          <span>Feature on homepage</span>
        </label>
      </div>

      {/* Preview Section */}
      {metadata && (
        <Card className="p-4 mb-6">
          <h3 className="font-semibold mb-4">Preview</h3>
          {metadata.image && (
            <img src={metadata.image} alt="Thumbnail" className="w-full h-48 object-cover rounded mb-4" />
          )}
          <Input
            value={metadata.title}
            onChange={(e) => setMetadata({...metadata, title: e.target.value})}
            className="mb-2"
          />
          <Textarea
            value={metadata.description}
            onChange={(e) => setMetadata({...metadata, description: e.target.value})}
            rows={3}
          />
          <div className="flex gap-2 mt-4 text-sm text-gray-600">
            <span className="px-2 py-1 bg-gray-100 rounded">{metadata.type}</span>
            <span className="px-2 py-1 bg-gray-100 rounded">{metadata.source}</span>
          </div>
        </Card>
      )}

      {/* Actions */}
      <div className="flex gap-2">
        <Button onClick={handlePublish} disabled={!metadata || !selectedCategory}>
          Publish
        </Button>
        <Button variant="outline">Save as Draft</Button>
      </div>
    </div>
  );
}
```

**Tasks**:
- [ ] Create admin content form component
- [ ] Add form validation
- [ ] Implement metadata fetching UI
- [ ] Add preview section
- [ ] Add success/error notifications
- [ ] Add routing for admin page

**Dependencies**: Task 2.2, Shadcn UI components  
**Estimated Time**: 3-4 hours  
**Complexity**: Medium-High

---

### Task 3.2: Create Admin Content List Page
**File**: `client/src/pages/AdminContentList.tsx` (new file)

**Description**: Admin page to view, edit, and delete content.

**Tasks**:
- [ ] Create content list table component
- [ ] Add edit/delete actions
- [ ] Add featured toggle
- [ ] Add filters (category, type, status)
- [ ] Add pagination

**Dependencies**: Task 2.2  
**Estimated Time**: 2-3 hours  
**Complexity**: Medium

---

## Phase 4: Public Frontend

### Task 4.1: Create Resources Hub Main Page
**File**: `client/src/pages/Resources.tsx` (new file)

**Description**: Public-facing resources page with categories and content grid.

**Implementation**: Based on mockup designs

**Tasks**:
- [ ] Create page layout component
- [ ] Implement featured content carousel
- [ ] Create category grid section
- [ ] Implement search bar
- [ ] Create content card grid with infinite scroll
- [ ] Add responsive design (mobile/tablet)

**Dependencies**: Task 2.2  
**Estimated Time**: 5-6 hours  
**Complexity**: High

---

### Task 4.2: Create Content Card Component
**File**: `client/src/components/ContentCard.tsx` (new file)

**Description**: Reusable content card component.

**Implementation**:
```typescript
interface ContentCardProps {
  id: number;
  title: string;
  thumbnailUrl: string;
  contentType: string;
  source: string;
  readingTime: number;
  url: string;
  isBookmarked?: boolean;
  onBookmark?: () => void;
}

export function ContentCard({ item }: { item: ContentCardProps }) {
  return (
    <a
      href={item.url}
      target="_blank"
      rel="noopener noreferrer"
      className="group block"
    >
      <div className="relative">
        <img 
          src={item.thumbnailUrl} 
          alt={item.title}
          className="aspect-video w-full object-cover rounded-lg"
        />
        <span className="absolute top-2 left-2 px-2 py-1 text-xs bg-black/70 text-white rounded">
          {item.contentType}
        </span>
      </div>
      <h3 className="mt-2 font-semibold line-clamp-2 group-hover:text-green-700">
        {item.title}
      </h3>
      <div className="flex items-center gap-2 mt-1 text-sm text-gray-600">
        <span>{item.source}</span>
        <span>·</span>
        <span>{item.readingTime} min read</span>
      </div>
    </a>
  );
}
```

**Tasks**:
- [ ] Create content card component
- [ ] Add hover effects
- [ ] Add bookmark button (authenticated users)
- [ ] Add share button
- [ ] Optimize image loading (lazy load)

**Dependencies**: None  
**Estimated Time**: 2 hours  
**Complexity**: Low-Medium

---

### Task 4.3: Implement Search & Filter
**File**: `client/src/components/ResourcesFilters.tsx` (new file)

**Description**: Search and filter interface for resources.

**Tasks**:
- [ ] Create search input with debounce
- [ ] Create filter sidebar/panel
- [ ] Add category filters
- [ ] Add content type filters
- [ ] Add sort options
- [ ] Show active filters as removable chips

**Dependencies**: Task 4.1  
**Estimated Time**: 3-4 hours  
**Complexity**: Medium-High

---

## Phase 5: User Features

### Task 5.1: Implement Bookmarking
**Files**: 
- `server/routes.ts` (API endpoints)
- `client/src/components/BookmarkButton.tsx` (new)

**Description**: Allow users to bookmark content (requires auth).

**Tasks**:
- [ ] Add bookmark API endpoints (POST/DELETE)
- [ ] Create bookmark button component
- [ ] Add optimistic updates with TanStack Query
- [ ] Add bookmarked content page
- [ ] Show bookmark count on cards

**Dependencies**: User authentication system  
**Estimated Time**: 2-3 hours  
**Complexity**: Medium

---

### Task 5.2: Add Social Sharing
**File**: `client/src/components/ShareButton.tsx` (new file)

**Description**: Social sharing functionality.

**Tasks**:
- [ ] Create share button component
- [ ] Add Twitter/X share
- [ ] Add Facebook share
- [ ] Add LinkedIn share
- [ ] Add copy link functionality
- [ ] Track share count

**Dependencies**: None  
**Estimated Time**: 1-2 hours  
**Complexity**: Low

---

## Phase 6: Polish & Optimization

### Task 6.1: Add Analytics Tracking
**File**: `server/routes.ts`

**Tasks**:
- [ ] Track content views
- [ ] Track shares
- [ ] Track bookmarks
- [ ] Create analytics dashboard endpoint
- [ ] Display popular content

**Dependencies**: Task 2.2  
**Estimated Time**: 2-3 hours  
**Complexity**: Medium

---

### Task 6.2: Performance Optimization
**Tasks**:
- [ ] Add database indexes (url, status, createdAt, viewCount)
- [ ] Implement Redis caching for popular queries
- [ ] Add CDN for thumbnail images
- [ ] Optimize images (WebP format)
- [ ] Add pagination/infinite scroll
- [ ] Lazy load images

**Dependencies**: All previous tasks  
**Estimated Time**: 3-4 hours  
**Complexity**: Medium

---

### Task 6.3: SEO & Metadata
**Tasks**:
- [ ] Add meta tags to resources page
- [ ] Generate sitemap for content
- [ ] Add structured data (JSON-LD)
- [ ] Implement canonical URLs
- [ ] Add Open Graph tags

**Dependencies**: Task 4.1  
**Estimated Time**: 2 hours  
**Complexity**: Low

---

## Comprehensive Test Plan

### 1. Unit Testing

#### Backend Unit Tests
**Location**: `server/__tests__/` (new directory)

**Metadata Fetcher Tests** (`metadata-fetcher.test.ts`):
- [ ] Test `fetchUrlMetadata()` with article URLs
- [ ] Test `fetchUrlMetadata()` with YouTube video URLs
- [ ] Test `fetchUrlMetadata()` with podcast URLs
- [ ] Test `extractDomain()` with various URL formats
- [ ] Test `estimateReadingTime()` calculation
- [ ] Test error handling for invalid URLs
- [ ] Test timeout handling for slow-loading pages

**Content API Tests** (`content-api.test.ts`):
- [ ] Test GET `/api/content` without filters
- [ ] Test GET `/api/content` with category filter
- [ ] Test GET `/api/content` with search query
- [ ] Test GET `/api/content` with pagination
- [ ] Test GET `/api/content/featured` returns only featured items
- [ ] Test GET `/api/content/:id` increments view count
- [ ] Test POST `/api/admin/content` creates content correctly
- [ ] Test POST `/api/admin/content/fetch-metadata` detects duplicates
- [ ] Test PATCH `/api/admin/content/:id` updates content
- [ ] Test DELETE `/api/admin/content/:id` removes content

#### Frontend Unit Tests
**Location**: `client/src/__tests__/` (new directory)

**Component Tests**:
- [ ] Test `ContentCard` renders correctly
- [ ] Test `ContentCard` handles missing thumbnail gracefully
- [ ] Test `BookmarkButton` toggles state
- [ ] Test `ShareButton` opens share dialog
- [ ] Test `ResourcesFilters` applies filters correctly
- [ ] Test search debouncing works

---

### 2. Integration Testing

#### Content Hub Flow Tests
- [ ] **Admin adds content**: Fetch metadata → preview → publish → verify on public page
- [ ] **Category filtering**: Select category → verify filtered results → clear filter
- [ ] **Search functionality**: Enter query → verify results → clear search
- [ ] **Bookmarking flow**: Login → bookmark content → verify in bookmarks page → unbookmark
- [ ] **Social sharing**: Click share → verify share links → track share count increment
- [ ] **Featured content**: Mark as featured in admin → verify appears in carousel
- [ ] **Pagination**: Load page 1 → navigate to page 2 → verify different content
- [ ] **View tracking**: Click content card → verify view count increments

#### API Integration Tests
- [ ] Test content creation → category mapping → retrieval with categories
- [ ] Test content creation → tag mapping → retrieval with tags
- [ ] Test bookmark creation → verify in user's bookmarks list
- [ ] Test duplicate URL submission → verify rejection with 409 status

---

### 3. Regression Testing (Existing Features)

> [!IMPORTANT]
> **Critical**: All existing features MUST continue working after Content Hub implementation

#### Product Management
- [ ] **GET `/api/products`**: Verify all products load correctly
- [ ] **Product listing page**: Verify UI displays products
- [ ] **Product details**: Verify individual product pages work
- [ ] **Product images**: Verify images load correctly
- [ ] **Product search/filter**: Verify existing filters still work

#### Rental System
- [ ] **POST `/api/rentals`**: Create new rental successfully
- [ ] **Rental form**: Verify form validation works
- [ ] **Date selection**: Verify rental date picker functions
- [ ] **Inventory checks**: Verify availability checking works
- [ ] **Price calculation**: Verify rental pricing calculates correctly
- [ ] **GET `/api/inventory/available`**: Verify inventory API still works

#### Notifications (Twilio & Email)
- [ ] **Order confirmations**: Verify SMS notifications send correctly
- [ ] **WhatsApp notifications**: Verify WhatsApp messages send
- [ ] **Email notifications**: Verify Nodemailer emails send
- [ ] **Twilio webhooks**: Verify webhook handling still works
- [ ] **Notification templates**: Verify message formatting is correct

#### Feedback System
- [ ] **POST `/api/feedback`**: Submit feedback successfully
- [ ] **Feedback form**: Verify form submission works
- [ ] **Feedback display**: Verify feedback appears correctly
- [ ] **Rating system**: Verify star ratings work

#### Database Operations
- [ ] **Database connections**: Verify Drizzle ORM connections stable
- [ ] **Existing migrations**: Verify no conflicts with new schema
- [ ] **Data integrity**: Verify existing data not corrupted
- [ ] **Foreign key constraints**: Verify relationships still enforced

#### Authentication & Authorization (if implemented)
- [ ] **User login**: Verify login flow works
- [ ] **User sessions**: Verify session management works
- [ ] **Admin access**: Verify admin routes are protected
- [ ] **User permissions**: Verify role-based access control works

---

### 4. Frontend Regression Testing

#### Navigation
- [ ] **Main navigation**: Verify all nav links work
- [ ] **New "Resources" menu item**: Verify integrates smoothly
- [ ] **Mobile menu**: Verify hamburger menu functions
- [ ] **Breadcrumbs**: Verify navigation breadcrumbs work

#### Responsive Design
- [ ] **Desktop view**: All existing pages render correctly
- [ ] **Tablet view**: Verify tablet breakpoints work
- [ ] **Mobile view**: Verify mobile layouts intact
- [ ] **New Resources page**: Test across all devices

#### UI Components
- [ ] **Existing forms**: Verify rental/feedback forms work
- [ ] **Buttons**: Verify all buttons clickable and styled
- [ ] **Modals/dialogs**: Verify popups/overlays function
- [ ] **Loading states**: Verify spinners/skeletons display

---

### 5. End-to-End (E2E) Testing

**Test Scenarios** (using browser automation):

**Scenario 1: Admin Content Management**
1. [ ] Login as admin
2. [ ] Navigate to admin content page
3. [ ] Paste article URL
4. [ ] Click "Fetch Details"
5. [ ] Verify metadata auto-fills
6. [ ] Select category
7. [ ] Mark as featured
8. [ ] Click "Publish"
9. [ ] Verify success message
10. [ ] Navigate to public resources page
11. [ ] Verify content appears

**Scenario 2: User Content Discovery**
1. [ ] Navigate to resources page
2. [ ] Browse featured carousel
3. [ ] Click category filter
4. [ ] Verify filtered results
5. [ ] Enter search query
6. [ ] Verify search results
7. [ ] Click content card
8. [ ] Verify external link opens
9. [ ] Return to resources page
10. [ ] Verify view count increased

**Scenario 3: User Bookmarking**
1. [ ] Login as regular user
2. [ ] Navigate to resources page
3. [ ] Click bookmark icon on content card
4. [ ] Verify bookmark icon fills
5. [ ] Navigate to bookmarks page
6. [ ] Verify content appears
7. [ ] Unbookmark content
8. [ ] Verify removed from bookmarks

**Scenario 4: Existing Rental Flow** (Regression)
1. [ ] Browse products page
2. [ ] Select product
3. [ ] Choose rental dates
4. [ ] Add to cart
5. [ ] Fill out rental form
6. [ ] Submit rental
7. [ ] Verify confirmation email/SMS
8. [ ] Check inventory updated

---

### 6. Performance Testing

#### Load Testing
- [ ] **Content listing**: Test with 1000+ content items
- [ ] **Search queries**: Test with complex search terms
- [ ] **Concurrent users**: Test 100+ simultaneous users
- [ ] **Image loading**: Test lazy loading with 50+ images
- [ ] **Database queries**: Monitor query performance with indexes

#### API Response Times
- [ ] `GET /api/content` responds in < 200ms
- [ ] `GET /api/content/featured` responds in < 100ms
- [ ] `POST /api/admin/content/fetch-metadata` responds in < 3s
- [ ] Search queries return in < 300ms

#### Database Performance
- [ ] Add indexes on: `url`, `status`, `createdAt`, `viewCount`
- [ ] Test query performance after indexing
- [ ] Monitor connection pool usage
- [ ] Test with large datasets (10,000+ content items)

---

### 7. Security Testing

#### Input Validation
- [ ] Test SQL injection attempts in search
- [ ] Test XSS attempts in admin form
- [ ] Test URL validation for malicious URLs
- [ ] Test file upload security (if thumbnails uploaded)

#### Authorization
- [ ] Test admin endpoints require admin role
- [ ] Test bookmark endpoints require authentication
- [ ] Test public endpoints accessible without auth
- [ ] Test CSRF protection on admin forms

#### Data Security
- [ ] Verify sensitive data not exposed in API responses
- [ ] Test rate limiting on public endpoints
- [ ] Verify no information leakage in error messages

---

### 8. Cross-Browser Testing

Test on:
- [ ] Chrome (latest)
- [ ] Firefox (latest)
- [ ] Safari (latest)
- [ ] Edge (latest)
- [ ] Mobile Safari (iOS)
- [ ] Mobile Chrome (Android)

**Features to test**:
- Resources page rendering
- Content card interactions
- Search and filters
- Featured carousel
- Bookmark functionality
- Social sharing

---

### 9. Accessibility Testing

- [ ] Screen reader compatibility (VoiceOver/NVDA)
- [ ] Keyboard navigation works throughout
- [ ] Proper ARIA labels on interactive elements
- [ ] Color contrast meets WCAG AA standards
- [ ] Focus indicators visible
- [ ] Alt text on all images

---

### 10. Database Migration Testing

**Pre-Deployment**:
- [ ] Backup existing database
- [ ] Run migration in staging environment
- [ ] Verify existing tables untouched
- [ ] Verify new tables created correctly
- [ ] Verify relationships/constraints enforced
- [ ] Test rollback procedure

**Post-Deployment**:
- [ ] Verify all existing data intact
- [ ] Run data integrity checks
- [ ] Monitor for migration errors

---

### 11. Smoke Testing Checklist

**Post-Deployment Critical Path**:
- [ ] Homepage loads
- [ ] Products page loads
- [ ] **New: Resources page loads**
- [ ] **New: Featured content displays**
- [ ] Create a test rental
- [ ] Submit test feedback
- [ ] **New: Admin can add content**
- [ ] **New: Search works**
- [ ] Verify no console errors
- [ ] Verify no API errors in logs

---

### 12. User Acceptance Testing (UAT)

**Admin User Testing**:
- [ ] Admin can easily add content (< 1 minute)
- [ ] Metadata auto-fetch works reliably
- [ ] Preview accurately represents final card
- [ ] Content management is intuitive

**End User Testing**:
- [ ] Resources page is discoverable
- [ ] Content is easy to browse
- [ ] Search is helpful
- [ ] Categories make sense
- [ ] Content cards are clickable and professional

**Regression UAT**:
- [ ] Existing rental flow feels unchanged
- [ ] Product browsing not affected
- [ ] No performance degradation noticed
- [ ] Navigation feels natural with new menu item

---

## Test Automation Recommendations

### Recommended Testing Tools
```bash
# Install testing dependencies
npm install --save-dev vitest @testing-library/react @testing-library/jest-dom
npm install --save-dev playwright # for E2E tests
npm install --save-dev supertest # for API tests
```

### Test Scripts to Add
```json
{
  "scripts": {
    "test": "vitest",
    "test:unit": "vitest run",
    "test:e2e": "playwright test",
    "test:api": "vitest run --config vitest.api.config.ts",
    "test:regression": "vitest run --config vitest.regression.config.ts"
  }
}
```

---

## Testing Timeline Estimate

| Test Type | Estimated Time |
|-----------|----------------|
| Unit Tests | 4-6 hours |
| Integration Tests | 3-4 hours |
| Regression Tests | 4-5 hours |
| E2E Tests | 3-4 hours |
| Performance Tests | 2-3 hours |
| Security Tests | 2-3 hours |
| Cross-Browser Tests | 2-3 hours |
| **Total** | **20-28 hours** |

---

## Critical Testing Priorities

### High Priority (Must Test Before Launch)
1. ✅ All regression tests pass (existing features work)
2. ✅ Admin content creation flow works end-to-end
3. ✅ Public resources page displays correctly
4. ✅ Database migrations successful
5. ✅ No breaking changes to existing APIs

### Medium Priority (Should Test Before Launch)
1. Search and filter functionality
2. Featured content carousel
3. Responsive design across devices
4. Performance benchmarks met

### Low Priority (Can Test Post-Launch)
1. Social sharing tracking
2. Bookmark functionality
3. Advanced filters
4. Analytics dashboard


---

## Deployment Checklist

- [ ] Run database migrations (`npm run db:push`)
- [ ] Seed initial categories (`npm run db:seed-categories`)
- [ ] Set up CDN for images (if applicable)
- [ ] Configure Redis for caching (if applicable)
- [ ] Add environment variables (if needed)
- [ ] Test in staging environment
- [ ] Deploy to production
- [ ] Monitor error logs and performance

---

## Dependencies & Prerequisites

### NPM Packages to Install
```bash
npm install cheerio node-fetch
```

### Existing Features Required
- [ ] User authentication system (for bookmarking)
- [ ] Admin role/permissions (for content management)

### Optional Enhancements (Future)
- [ ] Email notifications for new content
- [ ] RSS feed for content updates
- [ ] Related content recommendations (ML-based)
- [ ] Content comments/discussions
- [ ] User-submitted content (Phase 2 from requirements)

---

## Estimated Timeline

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| Phase 1: Database | 2 tasks | 2-3 hours |
| Phase 2: Backend API | 2 tasks | 6-8 hours |
| Phase 3: Admin Interface | 2 tasks | 5-7 hours |
| Phase 4: Public Frontend | 3 tasks | 10-12 hours |
| Phase 5: User Features | 2 tasks | 3-5 hours |
| Phase 6: Polish | 3 tasks | 7-9 hours |
| **Total** | **14 tasks** | **33-44 hours** |

---

## Next Steps
1. ✅ Review and approve this implementation plan
2. [ ] Set up development environment
3. [ ] Begin Phase 1: Database Schema Implementation
4. [ ] Test each phase incrementally before moving forward

